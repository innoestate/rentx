Refactorisation du store cette fois ci:

on créer un objet Data qui va gérer uniquement le store et sera finalement la façade.
On pourra par exemple dans cet objet data, gérer les messages de susccès ou d'erreur

non c'est pas top.
Data n'est pas censé faire des actions.

Par contre on pourrait utiliser la patern stratégie pour passer le service Data dans un error handler.
bof...

Le plus clair serait de faire un messageService qui gère les messages (de validation etc...), basé sur data.


Je dois quand même me poser la question du MessageService.
En effet, il faut pouvoir envoyer des messages de validation ou d'erreur lors des appels api par exemple.

La solution basique serait de mettre ce messageService dans le store.
Problème cela ne respecte pas la separation des responsabilites.

Il faudrait peut être une solution plus fine.

On pourait effectivement partir sur un service Message qui écouterait Data.
Et ajouter dans Data des emitters basés sur Actions$, tout simplement!

Ok du coup on garde ça en tête et pour l'instant on repart sur notre couche business.


AIE...
J'ai confondu ui et ui.
Il faudrait que je refactorise tous les ui-components en ui-components!.



// GESTION DES DONNEES

On va implémenter une façade data qui gère le store.

Pour mon objet estates, je veux qu'il m'envoie une seule fois l'objet estates avec les owners et lodgers une fois toutes les données récoltées.
Ensuite à chaue modification, d'un owner, lodger ou de l'estate, je veux qu'il soit émis.


actuellement, il y a un selector qui va se baser sur tous les autres selectors et envoyer l'objet complet.
C'est pas mal mais cela renvoie du coup un objet vide tant que les 3 autres selectors n'ont pas émis au moins une fois.


pour gérer le prblème on peut utiliser les actions handler.

Commencons par les test.


Je voudrais tester que mon service data a bien les estates chargées.

//MESSAGE SERVICE

Maintenant il s'agit de refactoriser les message service.

Afin de respecter le S de SOLIDE (SRP ou Single Responsability Principle), il faut que ce service soit indépendant.
Il doit être appelé depuis les bons endroits, et donc, pas le store.

Je suis tenté de l'utiliser dans l'object data par exemple.
Mais cela viole, me semble-t-il le S de Solid.

Idéalement, il faudrait qu'il puisse être appelé dans un fichier du type data.messages.ts
Ce service écouterait les datas et enverrai les message.
Dans ces conditions il pourrait être basé sur le store?
Ou dans l'idéal, il écouterait le data service.
